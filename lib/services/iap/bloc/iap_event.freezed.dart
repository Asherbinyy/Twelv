// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'iap_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$IAPEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IAPEventCopyWith<$Res> {
  factory $IAPEventCopyWith(IAPEvent value, $Res Function(IAPEvent) then) =
      _$IAPEventCopyWithImpl<$Res, IAPEvent>;
}

/// @nodoc
class _$IAPEventCopyWithImpl<$Res, $Val extends IAPEvent>
    implements $IAPEventCopyWith<$Res> {
  _$IAPEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartObservingCopyWith<$Res> {
  factory _$$StartObservingCopyWith(
          _$StartObserving value, $Res Function(_$StartObserving) then) =
      __$$StartObservingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartObservingCopyWithImpl<$Res>
    extends _$IAPEventCopyWithImpl<$Res, _$StartObserving>
    implements _$$StartObservingCopyWith<$Res> {
  __$$StartObservingCopyWithImpl(
      _$StartObserving _value, $Res Function(_$StartObserving) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartObserving implements StartObserving {
  const _$StartObserving();

  @override
  String toString() {
    return 'IAPEvent.startObserving()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartObserving);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return startObserving();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return startObserving?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (startObserving != null) {
      return startObserving();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return startObserving(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return startObserving?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (startObserving != null) {
      return startObserving(this);
    }
    return orElse();
  }
}

abstract class StartObserving implements IAPEvent {
  const factory StartObserving() = _$StartObserving;
}

/// @nodoc
abstract class _$$FetchProductsCopyWith<$Res> {
  factory _$$FetchProductsCopyWith(
          _$FetchProducts value, $Res Function(_$FetchProducts) then) =
      __$$FetchProductsCopyWithImpl<$Res>;
  @useResult
  $Res call({IAPType type});
}

/// @nodoc
class __$$FetchProductsCopyWithImpl<$Res>
    extends _$IAPEventCopyWithImpl<$Res, _$FetchProducts>
    implements _$$FetchProductsCopyWith<$Res> {
  __$$FetchProductsCopyWithImpl(
      _$FetchProducts _value, $Res Function(_$FetchProducts) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$FetchProducts(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as IAPType,
    ));
  }
}

/// @nodoc

class _$FetchProducts implements FetchProducts {
  const _$FetchProducts({required this.type});

  @override
  final IAPType type;

  @override
  String toString() {
    return 'IAPEvent.fetchProducts(type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchProducts &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchProductsCopyWith<_$FetchProducts> get copyWith =>
      __$$FetchProductsCopyWithImpl<_$FetchProducts>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return fetchProducts(type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return fetchProducts?.call(type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (fetchProducts != null) {
      return fetchProducts(type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return fetchProducts(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return fetchProducts?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (fetchProducts != null) {
      return fetchProducts(this);
    }
    return orElse();
  }
}

abstract class FetchProducts implements IAPEvent {
  const factory FetchProducts({required final IAPType type}) = _$FetchProducts;

  IAPType get type;
  @JsonKey(ignore: true)
  _$$FetchProductsCopyWith<_$FetchProducts> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BuyCopyWith<$Res> {
  factory _$$BuyCopyWith(_$Buy value, $Res Function(_$Buy) then) =
      __$$BuyCopyWithImpl<$Res>;
  @useResult
  $Res call({String productId});
}

/// @nodoc
class __$$BuyCopyWithImpl<$Res> extends _$IAPEventCopyWithImpl<$Res, _$Buy>
    implements _$$BuyCopyWith<$Res> {
  __$$BuyCopyWithImpl(_$Buy _value, $Res Function(_$Buy) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
  }) {
    return _then(_$Buy(
      productId: null == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Buy implements Buy {
  const _$Buy({required this.productId});

  @override
  final String productId;

  @override
  String toString() {
    return 'IAPEvent.buy(productId: $productId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Buy &&
            (identical(other.productId, productId) ||
                other.productId == productId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, productId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BuyCopyWith<_$Buy> get copyWith =>
      __$$BuyCopyWithImpl<_$Buy>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return buy(productId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return buy?.call(productId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (buy != null) {
      return buy(productId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return buy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return buy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (buy != null) {
      return buy(this);
    }
    return orElse();
  }
}

abstract class Buy implements IAPEvent {
  const factory Buy({required final String productId}) = _$Buy;

  String get productId;
  @JsonKey(ignore: true)
  _$$BuyCopyWith<_$Buy> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$CheckConsumeCopyWith<$Res> {
  factory _$$CheckConsumeCopyWith(
          _$CheckConsume value, $Res Function(_$CheckConsume) then) =
      __$$CheckConsumeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckConsumeCopyWithImpl<$Res>
    extends _$IAPEventCopyWithImpl<$Res, _$CheckConsume>
    implements _$$CheckConsumeCopyWith<$Res> {
  __$$CheckConsumeCopyWithImpl(
      _$CheckConsume _value, $Res Function(_$CheckConsume) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CheckConsume implements CheckConsume {
  const _$CheckConsume();

  @override
  String toString() {
    return 'IAPEvent.checkConsume()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$CheckConsume);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return checkConsume();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return checkConsume?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (checkConsume != null) {
      return checkConsume();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return checkConsume(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return checkConsume?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (checkConsume != null) {
      return checkConsume(this);
    }
    return orElse();
  }
}

abstract class CheckConsume implements IAPEvent {
  const factory CheckConsume() = _$CheckConsume;
}

/// @nodoc
abstract class _$$PurchaseResponseReceivedCopyWith<$Res> {
  factory _$$PurchaseResponseReceivedCopyWith(_$PurchaseResponseReceived value,
          $Res Function(_$PurchaseResponseReceived) then) =
      __$$PurchaseResponseReceivedCopyWithImpl<$Res>;
  @useResult
  $Res call({InAppPurchaseResponse response});
}

/// @nodoc
class __$$PurchaseResponseReceivedCopyWithImpl<$Res>
    extends _$IAPEventCopyWithImpl<$Res, _$PurchaseResponseReceived>
    implements _$$PurchaseResponseReceivedCopyWith<$Res> {
  __$$PurchaseResponseReceivedCopyWithImpl(_$PurchaseResponseReceived _value,
      $Res Function(_$PurchaseResponseReceived) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? response = null,
  }) {
    return _then(_$PurchaseResponseReceived(
      response: null == response
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as InAppPurchaseResponse,
    ));
  }
}

/// @nodoc

class _$PurchaseResponseReceived implements PurchaseResponseReceived {
  const _$PurchaseResponseReceived({required this.response});

  @override
  final InAppPurchaseResponse response;

  @override
  String toString() {
    return 'IAPEvent.purchaseResponseReceived(response: $response)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PurchaseResponseReceived &&
            (identical(other.response, response) ||
                other.response == response));
  }

  @override
  int get hashCode => Object.hash(runtimeType, response);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PurchaseResponseReceivedCopyWith<_$PurchaseResponseReceived>
      get copyWith =>
          __$$PurchaseResponseReceivedCopyWithImpl<_$PurchaseResponseReceived>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return purchaseResponseReceived(response);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return purchaseResponseReceived?.call(response);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (purchaseResponseReceived != null) {
      return purchaseResponseReceived(response);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return purchaseResponseReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return purchaseResponseReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (purchaseResponseReceived != null) {
      return purchaseResponseReceived(this);
    }
    return orElse();
  }
}

abstract class PurchaseResponseReceived implements IAPEvent {
  const factory PurchaseResponseReceived(
          {required final InAppPurchaseResponse response}) =
      _$PurchaseResponseReceived;

  InAppPurchaseResponse get response;
  @JsonKey(ignore: true)
  _$$PurchaseResponseReceivedCopyWith<_$PurchaseResponseReceived>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PurchaseResponseErrorReceivedCopyWith<$Res> {
  factory _$$PurchaseResponseErrorReceivedCopyWith(
          _$PurchaseResponseErrorReceived value,
          $Res Function(_$PurchaseResponseErrorReceived) then) =
      __$$PurchaseResponseErrorReceivedCopyWithImpl<$Res>;
  @useResult
  $Res call({InAppPurchaseError error});
}

/// @nodoc
class __$$PurchaseResponseErrorReceivedCopyWithImpl<$Res>
    extends _$IAPEventCopyWithImpl<$Res, _$PurchaseResponseErrorReceived>
    implements _$$PurchaseResponseErrorReceivedCopyWith<$Res> {
  __$$PurchaseResponseErrorReceivedCopyWithImpl(
      _$PurchaseResponseErrorReceived _value,
      $Res Function(_$PurchaseResponseErrorReceived) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$PurchaseResponseErrorReceived(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as InAppPurchaseError,
    ));
  }
}

/// @nodoc

class _$PurchaseResponseErrorReceived implements PurchaseResponseErrorReceived {
  const _$PurchaseResponseErrorReceived({required this.error});

  @override
  final InAppPurchaseError error;

  @override
  String toString() {
    return 'IAPEvent.purchaseResponseErrorReceived(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PurchaseResponseErrorReceived &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PurchaseResponseErrorReceivedCopyWith<_$PurchaseResponseErrorReceived>
      get copyWith => __$$PurchaseResponseErrorReceivedCopyWithImpl<
          _$PurchaseResponseErrorReceived>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return purchaseResponseErrorReceived(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return purchaseResponseErrorReceived?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (purchaseResponseErrorReceived != null) {
      return purchaseResponseErrorReceived(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return purchaseResponseErrorReceived(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return purchaseResponseErrorReceived?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (purchaseResponseErrorReceived != null) {
      return purchaseResponseErrorReceived(this);
    }
    return orElse();
  }
}

abstract class PurchaseResponseErrorReceived implements IAPEvent {
  const factory PurchaseResponseErrorReceived(
          {required final InAppPurchaseError error}) =
      _$PurchaseResponseErrorReceived;

  InAppPurchaseError get error;
  @JsonKey(ignore: true)
  _$$PurchaseResponseErrorReceivedCopyWith<_$PurchaseResponseErrorReceived>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnknowExceptionCopyWith<$Res> {
  factory _$$UnknowExceptionCopyWith(
          _$UnknowException value, $Res Function(_$UnknowException) then) =
      __$$UnknowExceptionCopyWithImpl<$Res>;
  @useResult
  $Res call({dynamic error});
}

/// @nodoc
class __$$UnknowExceptionCopyWithImpl<$Res>
    extends _$IAPEventCopyWithImpl<$Res, _$UnknowException>
    implements _$$UnknowExceptionCopyWith<$Res> {
  __$$UnknowExceptionCopyWithImpl(
      _$UnknowException _value, $Res Function(_$UnknowException) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$UnknowException(
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc

class _$UnknowException implements UnknowException {
  const _$UnknowException({required this.error});

  @override
  final dynamic error;

  @override
  String toString() {
    return 'IAPEvent.unknowException(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnknowException &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnknowExceptionCopyWith<_$UnknowException> get copyWith =>
      __$$UnknowExceptionCopyWithImpl<_$UnknowException>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() startObserving,
    required TResult Function(IAPType type) fetchProducts,
    required TResult Function(String productId) buy,
    required TResult Function() checkConsume,
    required TResult Function(InAppPurchaseResponse response)
        purchaseResponseReceived,
    required TResult Function(InAppPurchaseError error)
        purchaseResponseErrorReceived,
    required TResult Function(dynamic error) unknowException,
  }) {
    return unknowException(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? startObserving,
    TResult? Function(IAPType type)? fetchProducts,
    TResult? Function(String productId)? buy,
    TResult? Function()? checkConsume,
    TResult? Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult? Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult? Function(dynamic error)? unknowException,
  }) {
    return unknowException?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? startObserving,
    TResult Function(IAPType type)? fetchProducts,
    TResult Function(String productId)? buy,
    TResult Function()? checkConsume,
    TResult Function(InAppPurchaseResponse response)? purchaseResponseReceived,
    TResult Function(InAppPurchaseError error)? purchaseResponseErrorReceived,
    TResult Function(dynamic error)? unknowException,
    required TResult orElse(),
  }) {
    if (unknowException != null) {
      return unknowException(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartObserving value) startObserving,
    required TResult Function(FetchProducts value) fetchProducts,
    required TResult Function(Buy value) buy,
    required TResult Function(CheckConsume value) checkConsume,
    required TResult Function(PurchaseResponseReceived value)
        purchaseResponseReceived,
    required TResult Function(PurchaseResponseErrorReceived value)
        purchaseResponseErrorReceived,
    required TResult Function(UnknowException value) unknowException,
  }) {
    return unknowException(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartObserving value)? startObserving,
    TResult? Function(FetchProducts value)? fetchProducts,
    TResult? Function(Buy value)? buy,
    TResult? Function(CheckConsume value)? checkConsume,
    TResult? Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult? Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult? Function(UnknowException value)? unknowException,
  }) {
    return unknowException?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartObserving value)? startObserving,
    TResult Function(FetchProducts value)? fetchProducts,
    TResult Function(Buy value)? buy,
    TResult Function(CheckConsume value)? checkConsume,
    TResult Function(PurchaseResponseReceived value)? purchaseResponseReceived,
    TResult Function(PurchaseResponseErrorReceived value)?
        purchaseResponseErrorReceived,
    TResult Function(UnknowException value)? unknowException,
    required TResult orElse(),
  }) {
    if (unknowException != null) {
      return unknowException(this);
    }
    return orElse();
  }
}

abstract class UnknowException implements IAPEvent {
  const factory UnknowException({required final dynamic error}) =
      _$UnknowException;

  dynamic get error;
  @JsonKey(ignore: true)
  _$$UnknowExceptionCopyWith<_$UnknowException> get copyWith =>
      throw _privateConstructorUsedError;
}
