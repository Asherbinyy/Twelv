// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'explorer_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ExplorerState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplorerStateCopyWith<$Res> {
  factory $ExplorerStateCopyWith(
          ExplorerState value, $Res Function(ExplorerState) then) =
      _$ExplorerStateCopyWithImpl<$Res, ExplorerState>;
}

/// @nodoc
class _$ExplorerStateCopyWithImpl<$Res, $Val extends ExplorerState>
    implements $ExplorerStateCopyWith<$Res> {
  _$ExplorerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialCopyWith<$Res> {
  factory _$$InitialCopyWith(_$Initial value, $Res Function(_$Initial) then) =
      __$$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$Initial>
    implements _$$InitialCopyWith<$Res> {
  __$$InitialCopyWithImpl(_$Initial _value, $Res Function(_$Initial) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Initial implements Initial {
  const _$Initial();

  @override
  String toString() {
    return 'ExplorerState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements ExplorerState {
  const factory Initial() = _$Initial;
}

/// @nodoc
abstract class _$$LoadingCopyWith<$Res> {
  factory _$$LoadingCopyWith(_$Loading value, $Res Function(_$Loading) then) =
      __$$LoadingCopyWithImpl<$Res>;
  @useResult
  $Res call({bool delay});
}

/// @nodoc
class __$$LoadingCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$Loading>
    implements _$$LoadingCopyWith<$Res> {
  __$$LoadingCopyWithImpl(_$Loading _value, $Res Function(_$Loading) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? delay = null,
  }) {
    return _then(_$Loading(
      delay: null == delay
          ? _value.delay
          : delay // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$Loading implements Loading {
  const _$Loading({required this.delay});

  @override
  final bool delay;

  @override
  String toString() {
    return 'ExplorerState.loading(delay: $delay)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Loading &&
            (identical(other.delay, delay) || other.delay == delay));
  }

  @override
  int get hashCode => Object.hash(runtimeType, delay);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadingCopyWith<_$Loading> get copyWith =>
      __$$LoadingCopyWithImpl<_$Loading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return loading(delay);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return loading?.call(delay);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(delay);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class Loading implements ExplorerState {
  const factory Loading({required final bool delay}) = _$Loading;

  bool get delay;
  @JsonKey(ignore: true)
  _$$LoadingCopyWith<_$Loading> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExplorerErrorCopyWith<$Res> {
  factory _$$ExplorerErrorCopyWith(
          _$ExplorerError value, $Res Function(_$ExplorerError) then) =
      __$$ExplorerErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({Exception error, ExplorerEvent event});

  $ExplorerEventCopyWith<$Res> get event;
}

/// @nodoc
class __$$ExplorerErrorCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$ExplorerError>
    implements _$$ExplorerErrorCopyWith<$Res> {
  __$$ExplorerErrorCopyWithImpl(
      _$ExplorerError _value, $Res Function(_$ExplorerError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
    Object? event = null,
  }) {
    return _then(_$ExplorerError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Exception,
      null == event
          ? _value.event
          : event // ignore: cast_nullable_to_non_nullable
              as ExplorerEvent,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExplorerEventCopyWith<$Res> get event {
    return $ExplorerEventCopyWith<$Res>(_value.event, (value) {
      return _then(_value.copyWith(event: value));
    });
  }
}

/// @nodoc

class _$ExplorerError implements ExplorerError {
  const _$ExplorerError(this.error, this.event);

  @override
  final Exception error;
  @override
  final ExplorerEvent event;

  @override
  String toString() {
    return 'ExplorerState.explorerError(error: $error, event: $event)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExplorerError &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.event, event) || other.event == event));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, event);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ExplorerErrorCopyWith<_$ExplorerError> get copyWith =>
      __$$ExplorerErrorCopyWithImpl<_$ExplorerError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return explorerError(error, event);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return explorerError?.call(error, event);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (explorerError != null) {
      return explorerError(error, event);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return explorerError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return explorerError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (explorerError != null) {
      return explorerError(this);
    }
    return orElse();
  }
}

abstract class ExplorerError implements ExplorerState {
  const factory ExplorerError(
      final Exception error, final ExplorerEvent event) = _$ExplorerError;

  Exception get error;
  ExplorerEvent get event;
  @JsonKey(ignore: true)
  _$$ExplorerErrorCopyWith<_$ExplorerError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchedDataCopyWith<$Res> {
  factory _$$FetchedDataCopyWith(
          _$FetchedData value, $Res Function(_$FetchedData) then) =
      __$$FetchedDataCopyWithImpl<$Res>;
  @useResult
  $Res call({Profiles userRecommendations, bool isAfterReportingProfile});
}

/// @nodoc
class __$$FetchedDataCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$FetchedData>
    implements _$$FetchedDataCopyWith<$Res> {
  __$$FetchedDataCopyWithImpl(
      _$FetchedData _value, $Res Function(_$FetchedData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userRecommendations = null,
    Object? isAfterReportingProfile = null,
  }) {
    return _then(_$FetchedData(
      null == userRecommendations
          ? _value.userRecommendations
          : userRecommendations // ignore: cast_nullable_to_non_nullable
              as Profiles,
      isAfterReportingProfile: null == isAfterReportingProfile
          ? _value.isAfterReportingProfile
          : isAfterReportingProfile // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$FetchedData implements FetchedData {
  const _$FetchedData(this.userRecommendations,
      {this.isAfterReportingProfile = false});

  @override
  final Profiles userRecommendations;
  @override
  @JsonKey()
  final bool isAfterReportingProfile;

  @override
  String toString() {
    return 'ExplorerState.fetchedData(userRecommendations: $userRecommendations, isAfterReportingProfile: $isAfterReportingProfile)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchedData &&
            (identical(other.userRecommendations, userRecommendations) ||
                other.userRecommendations == userRecommendations) &&
            (identical(
                    other.isAfterReportingProfile, isAfterReportingProfile) ||
                other.isAfterReportingProfile == isAfterReportingProfile));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, userRecommendations, isAfterReportingProfile);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchedDataCopyWith<_$FetchedData> get copyWith =>
      __$$FetchedDataCopyWithImpl<_$FetchedData>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return fetchedData(userRecommendations, isAfterReportingProfile);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return fetchedData?.call(userRecommendations, isAfterReportingProfile);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (fetchedData != null) {
      return fetchedData(userRecommendations, isAfterReportingProfile);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return fetchedData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return fetchedData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (fetchedData != null) {
      return fetchedData(this);
    }
    return orElse();
  }
}

abstract class FetchedData implements ExplorerState {
  const factory FetchedData(final Profiles userRecommendations,
      {final bool isAfterReportingProfile}) = _$FetchedData;

  Profiles get userRecommendations;
  bool get isAfterReportingProfile;
  @JsonKey(ignore: true)
  _$$FetchedDataCopyWith<_$FetchedData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MatchCopyWith<$Res> {
  factory _$$MatchCopyWith(_$Match value, $Res Function(_$Match) then) =
      __$$MatchCopyWithImpl<$Res>;
  @useResult
  $Res call({SwipeMatch swipeMatch, BaseUser userRecommended});
}

/// @nodoc
class __$$MatchCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$Match>
    implements _$$MatchCopyWith<$Res> {
  __$$MatchCopyWithImpl(_$Match _value, $Res Function(_$Match) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? swipeMatch = null,
    Object? userRecommended = null,
  }) {
    return _then(_$Match(
      null == swipeMatch
          ? _value.swipeMatch
          : swipeMatch // ignore: cast_nullable_to_non_nullable
              as SwipeMatch,
      null == userRecommended
          ? _value.userRecommended
          : userRecommended // ignore: cast_nullable_to_non_nullable
              as BaseUser,
    ));
  }
}

/// @nodoc

class _$Match implements Match {
  const _$Match(this.swipeMatch, this.userRecommended);

  @override
  final SwipeMatch swipeMatch;
  @override
  final BaseUser userRecommended;

  @override
  String toString() {
    return 'ExplorerState.match(swipeMatch: $swipeMatch, userRecommended: $userRecommended)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Match &&
            (identical(other.swipeMatch, swipeMatch) ||
                other.swipeMatch == swipeMatch) &&
            (identical(other.userRecommended, userRecommended) ||
                other.userRecommended == userRecommended));
  }

  @override
  int get hashCode => Object.hash(runtimeType, swipeMatch, userRecommended);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MatchCopyWith<_$Match> get copyWith =>
      __$$MatchCopyWithImpl<_$Match>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return match(swipeMatch, userRecommended);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return match?.call(swipeMatch, userRecommended);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (match != null) {
      return match(swipeMatch, userRecommended);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return match(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return match?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (match != null) {
      return match(this);
    }
    return orElse();
  }
}

abstract class Match implements ExplorerState {
  const factory Match(
      final SwipeMatch swipeMatch, final BaseUser userRecommended) = _$Match;

  SwipeMatch get swipeMatch;
  BaseUser get userRecommended;
  @JsonKey(ignore: true)
  _$$MatchCopyWith<_$Match> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuperlikedCopyWith<$Res> {
  factory _$$SuperlikedCopyWith(
          _$Superliked value, $Res Function(_$Superliked) then) =
      __$$SuperlikedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SuperlikedCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$Superliked>
    implements _$$SuperlikedCopyWith<$Res> {
  __$$SuperlikedCopyWithImpl(
      _$Superliked _value, $Res Function(_$Superliked) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Superliked implements Superliked {
  const _$Superliked();

  @override
  String toString() {
    return 'ExplorerState.superliked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Superliked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return superliked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return superliked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (superliked != null) {
      return superliked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return superliked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return superliked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (superliked != null) {
      return superliked(this);
    }
    return orElse();
  }
}

abstract class Superliked implements ExplorerState {
  const factory Superliked() = _$Superliked;
}

/// @nodoc
abstract class _$$NoLocationCopyWith<$Res> {
  factory _$$NoLocationCopyWith(
          _$NoLocation value, $Res Function(_$NoLocation) then) =
      __$$NoLocationCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoLocationCopyWithImpl<$Res>
    extends _$ExplorerStateCopyWithImpl<$Res, _$NoLocation>
    implements _$$NoLocationCopyWith<$Res> {
  __$$NoLocationCopyWithImpl(
      _$NoLocation _value, $Res Function(_$NoLocation) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoLocation implements NoLocation {
  const _$NoLocation();

  @override
  String toString() {
    return 'ExplorerState.noLocation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoLocation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(bool delay) loading,
    required TResult Function(Exception error, ExplorerEvent event)
        explorerError,
    required TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)
        fetchedData,
    required TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)
        match,
    required TResult Function() superliked,
    required TResult Function() noLocation,
  }) {
    return noLocation();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function(bool delay)? loading,
    TResult? Function(Exception error, ExplorerEvent event)? explorerError,
    TResult? Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult? Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult? Function()? superliked,
    TResult? Function()? noLocation,
  }) {
    return noLocation?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(bool delay)? loading,
    TResult Function(Exception error, ExplorerEvent event)? explorerError,
    TResult Function(
            Profiles userRecommendations, bool isAfterReportingProfile)?
        fetchedData,
    TResult Function(SwipeMatch swipeMatch, BaseUser userRecommended)? match,
    TResult Function()? superliked,
    TResult Function()? noLocation,
    required TResult orElse(),
  }) {
    if (noLocation != null) {
      return noLocation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(Loading value) loading,
    required TResult Function(ExplorerError value) explorerError,
    required TResult Function(FetchedData value) fetchedData,
    required TResult Function(Match value) match,
    required TResult Function(Superliked value) superliked,
    required TResult Function(NoLocation value) noLocation,
  }) {
    return noLocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Initial value)? initial,
    TResult? Function(Loading value)? loading,
    TResult? Function(ExplorerError value)? explorerError,
    TResult? Function(FetchedData value)? fetchedData,
    TResult? Function(Match value)? match,
    TResult? Function(Superliked value)? superliked,
    TResult? Function(NoLocation value)? noLocation,
  }) {
    return noLocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(Loading value)? loading,
    TResult Function(ExplorerError value)? explorerError,
    TResult Function(FetchedData value)? fetchedData,
    TResult Function(Match value)? match,
    TResult Function(Superliked value)? superliked,
    TResult Function(NoLocation value)? noLocation,
    required TResult orElse(),
  }) {
    if (noLocation != null) {
      return noLocation(this);
    }
    return orElse();
  }
}

abstract class NoLocation implements ExplorerState {
  const factory NoLocation() = _$NoLocation;
}
